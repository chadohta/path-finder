{"version":3,"sources":["components/GridNode.jsx","algorithms/helper-functions.js","algorithms/Dijkstras.js","algorithms/GreedySearch.js","algorithms/AStarSearch.js","components/instructions.jsx","components/PathFindingVisualizer.jsx","algorithms/BreadthFirstSearch.js","algorithms/DepthFirstSearch.js","App.js","serviceWorker.js","index.js"],"names":["GridNode","this","props","col","row","isStart","isFinish","isWall","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","Component","getAllNodes","grid","nodes","node","push","getNeighbors","neighbors","length","filter","neighbor","getNodesInPathOrder","finishNode","nodesInPathOrder","currentNode","unshift","previousNode","getManhattanDistance","nodeA","nodeB","Math","abs","updateUnvisitedNeighbors","unvisitedNeighbors","isVisited","distance","updateNeighbors","pQueue","temp","fScore","includes","Instuctions","state","PathFindingVisualizer","mouseIsPressed","createGrid","currentRow","createNode","setState","Infinity","newGrid","getNewGridWithWallToggled","slice","newNode","document","querySelectorAll","forEach","button","disabled","lockButtons","startNode","visitedNodesInOrder","unvisitedNodes","sort","a","b","closestNode","shift","dijkstra","nodesInShortestPathOrder","animateExploration","console","log","greedySearch","aStarSearch","queue","bfs","stack","pop","dfs","speed","i","setTimeout","animatePath","getElementById","unlockResetButtons","resetNodeColor","allNodes","unlockSearchButtons","onClick","visualizeDFS","visualizeBFS","visualizeDijkstra","visualizeGreedy","visualizeAStar","map","rIndex","key","nIndex","handleMouseDown","handleMouseEnter","handleMouseUp","resetGrid","resetGridKeepWalls","style","fontStyle","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"yVAgCeA,G,mLA5BD,IAAD,EASGC,KAAKC,MARLC,EADH,EACGA,IACAC,EAFH,EAEGA,IACAC,EAHH,EAGGA,QACAC,EAJH,EAIGA,SACAC,EALH,EAKGA,OACAC,EANH,EAMGA,YACAC,EAPH,EAOGA,aACAC,EARH,EAQGA,UAGFC,EAAiBL,EAAW,cACRD,EAAU,aACVE,EAAS,YACT,GAE1B,OACI,yBACIK,GAAE,eAAUR,EAAV,YAAiBD,GACnBU,UAAS,eAAUF,GACnBH,YAAa,kBAAMA,EAAYJ,EAAKD,IACpCM,aAAc,kBAAMA,EAAaL,EAAKD,IACtCO,UAAW,kBAAMA,W,GAvBVI,cCFhB,SAASC,EAAYC,GACxB,IAD8B,EACxBC,EAAQ,GADgB,cAEZD,GAFY,IAE9B,2BAAwB,CAAC,IAAD,EAAbZ,EAAa,sBACDA,GADC,IACpB,2BAAwB,CAAC,IAAdc,EAAa,QACpBD,EAAME,KAAKD,IAFK,gCAFM,8BAO9B,OAAOD,EAIJ,SAASG,EAAaF,EAAMF,GAC/B,IAAMK,EAAY,GACVlB,EAAae,EAAbf,IAAKC,EAAQc,EAARd,IAKb,OAJID,EAAM,GAAGkB,EAAUF,KAAKH,EAAKZ,GAAKD,EAAM,IACxCC,EAAMY,EAAKM,OAAS,GAAGD,EAAUF,KAAKH,EAAKZ,EAAM,GAAGD,IACpDA,EAAMa,EAAK,GAAGM,OAAS,GAAGD,EAAUF,KAAKH,EAAKZ,GAAKD,EAAM,IACzDC,EAAM,GAAGiB,EAAUF,KAAKH,EAAKZ,EAAM,GAAGD,IACnCkB,EAAUE,QAAO,SAAAC,GAAQ,OAAKA,EAASjB,UAK3C,SAASkB,EAAoBC,GAGhC,IAFA,IAAMC,EAAmB,GACrBC,EAAcF,EACK,OAAhBE,GACHD,EAAiBE,QAAQD,GACzBA,EAAcA,EAAYE,aAE9B,OAAOH,EAIJ,SAASI,EAAqBC,EAAOC,GAGxC,OAFWC,KAAKC,IAAIH,EAAM7B,IAAM8B,EAAM9B,KAC3B+B,KAAKC,IAAIH,EAAM5B,IAAM6B,EAAM7B,KCf1C,SAASgC,EAAyBlB,EAAMF,GACpC,IAD0C,EAEpCqB,EADYjB,EAAaF,EAAMF,GACAO,QAAO,SAAAC,GAAQ,OAAKA,EAASc,aAFxB,cAGnBD,GAHmB,IAG1C,2BAA2C,CAAC,IAAjCb,EAAgC,QACvCA,EAASe,SAAWrB,EAAKqB,SAAW,EACpCf,EAASM,aAAeZ,GALc,+BCC9C,SAASkB,EAAyBlB,EAAMF,EAAMU,GAC1C,IADsD,EAEhDW,EADYjB,EAAaF,EAAMF,GACAO,QAAO,SAAAC,GAAQ,OAAKA,EAASc,aAFZ,cAG/BD,GAH+B,IAGtD,2BAA2C,CAAC,IAAjCb,EAAgC,QACvCA,EAASe,SAAWR,EAAqBP,EAAUE,GACnDF,EAASM,aAAeZ,GAL0B,+BCD1D,SAASsB,EAAgBtB,EAAMF,EAAMU,EAAYe,GAC7C,IADqD,EAC/CpB,EAAYD,EAAaF,EAAMF,GADgB,cAE9BK,GAF8B,IAErD,2BAAkC,CAAC,IAAxBG,EAAuB,QACxBkB,EAAOxB,EAAKqB,SAAW,EACzBG,EAAOlB,EAASe,WAChBf,EAASM,aAAeZ,EACxBM,EAASe,SAAWG,EACpBlB,EAASmB,OAASD,EAAOX,EAAqBP,EAAUE,GACnDe,EAAOG,SAASpB,IACjBiB,EAAOtB,KAAKK,KAT6B,+B,UC+E1CqB,E,4MAjGXC,MAAQ,G,uDAEJ,OACI,6BACI,sDACA,yVASA,gDAEA,yBAAKjC,UAAU,qBACX,0DACA,uBAAGA,UAAU,kBAAb,gBACA,uBAAGA,UAAU,WAAb,gIAIA,gEAKJ,yBAAKA,UAAU,qBACX,4DACA,uBAAGA,UAAU,kBAAb,kCACA,uBAAGA,UAAU,WAAb,6IAKA,wDAKJ,yBAAKA,UAAU,qBACX,sDACA,uBAAGA,UAAU,kBAAb,cACA,uBAAGA,UAAU,WAAb,iQAMA,wDAKJ,yBAAKA,UAAU,qBACX,+CACA,uBAAGA,UAAU,kBAAb,cACA,uBAAGA,UAAU,WAAb,6QAMA,gEAKJ,yBAAKA,UAAU,qBACX,oDACA,uBAAGA,UAAU,kBAAb,cACA,uBAAGA,UAAU,WAAb,qbASA,wDAKJ,sDACA,oM,GAxFUC,aC+SXiC,E,4MAjSXD,MAAQ,CACJ9B,KAAM,GACNgC,gBAAgB,G,kEAIhB/C,KAAKgD,e,mCAKL,IADA,IAAMjC,EAAO,GACJZ,EAAM,EAAGA,EAAM,GAAIA,IAAO,CAE/B,IADA,IAAM8C,EAAa,GACV/C,EAAM,EAAGA,EAAM,GAAIA,IACxB+C,EAAW/B,KAAKlB,KAAKkD,WAAWhD,EAAKC,IAEzCY,EAAKG,KAAK+B,GAEdjD,KAAKmD,SAAS,CACVpC,KAAMA,M,iCAIHb,EAAKC,GACZ,MAAO,CACHD,IAAKA,EACLC,IAAKA,EACLmC,SAAUc,IACVV,OAAQU,IACRvB,aAAc,KACdzB,QApCW,IAoCFD,GAnCE,IAmCwBD,EACnCG,SAnCS,KAmCCF,GAlCD,KAkCyBD,EAClCI,QAAQ,EACR+B,WAAW,K,sCAIHlC,EAAKD,GACjB,IAAMmD,EAAUrD,KAAKsD,0BAA0BtD,KAAK6C,MAAM9B,KAAMZ,EAAKD,GACrEF,KAAKmD,SAAS,CAAEpC,KAAMsC,EAASN,gBAAgB,M,uCAGlC5C,EAAKD,GAClB,GAAKF,KAAK6C,MAAME,eAAhB,CACA,IAAMM,EAAUrD,KAAKsD,0BAA0BtD,KAAK6C,MAAM9B,KAAMZ,EAAKD,GACrEF,KAAKmD,SAAS,CAAEpC,KAAMsC,O,sCAItBrD,KAAKmD,SAAS,CAAEJ,gBAAgB,M,gDAGVhC,EAAMZ,EAAKD,GACjC,IAAMmD,EAAUtC,EAAKwC,QACftC,EAAOoC,EAAQlD,GAAKD,GACpBsD,EAAO,2BACNvC,GADM,IAETX,QAASW,EAAKX,SAGlB,OADA+C,EAAQlD,GAAKD,GAAOsD,EACbH,I,oCAISI,SAASC,iBAAiB,UAClCC,SAAQ,SAACC,GACbA,EAAOC,UAAW,O,4CAKNJ,SAASC,iBAAiB,cAClCC,SAAQ,SAACC,GACbA,EAAOC,UAAW,O,2CAKNJ,SAASC,iBAAiB,aAClCC,SAAQ,SAACC,GACbA,EAAOC,UAAW,O,0CAKtB7D,KAAK8D,cADW,IAER/C,EAASf,KAAK6C,MAAd9B,KACFgD,EAAYhD,EA7FH,GACA,GA6FTU,EAAaV,EA5FN,IACA,IA4FPiD,EJxGP,SAAkBjD,EAAMgD,EAAWtC,GACtC,IAAMuC,EAAsB,GAC5BD,EAAUzB,SAAW,EAGrB,IAFA,IAAM2B,EAAiBnD,EAAYC,GAE5BkD,EAAe5C,OAAS,GAAG,CAE9B4C,EAAeC,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAE7B,SAAW8B,EAAE9B,YAC7C,IAAM+B,EAAcJ,EAAeK,QAGnC,GAAID,EAAY/B,WAAac,IAAU,OAAOY,EAI9C,GAFAK,EAAYhC,WAAY,EACxB2B,EAAoB9C,KAAKmD,GACrBA,IAAgB5C,EAAY,OAAOuC,EACvC7B,EAAyBkC,EAAatD,IIwFVwD,CAASxD,EAAMgD,EAAWtC,GAChD+C,EAA2BhD,EAAoBC,GACrDzB,KAAKyE,mBAAmBT,EAAqBQ,EAA0B,IACvEE,QAAQC,IAAI5D,K,wCAIZf,KAAK8D,cADS,IAEN/C,EAASf,KAAK6C,MAAd9B,KACFgD,EAAYhD,EAxGH,GACA,GAwGTU,EAAaV,EAvGN,IACA,IAuGPiD,EHnHP,SAAsBjD,EAAMgD,EAAWtC,GAC1C,IAAMuC,EAAsB,GACtBC,EAAiBnD,EAAYC,GAInC,IAFAgD,EAAUzB,SAAWR,EAAqBiC,EAAWtC,GAE9CwC,EAAe5C,OAAS,GAAG,CAE9B4C,EAAeC,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAE7B,SAAW8B,EAAE9B,YAC7C,IAAM+B,EAAcJ,EAAeK,QAGnC,GAAID,EAAY/B,WAAac,IAAU,OAAOY,EAI9C,GAFAK,EAAYhC,WAAY,EACxB2B,EAAoB9C,KAAKmD,GACrBA,IAAgB5C,EAAY,OAAOuC,EACvC7B,EAAyBkC,EAAatD,EAAMU,IGkGhBmD,CAAa7D,EAAMgD,EAAWtC,GACpDC,EAAmBF,EAAoBC,GAC7CzB,KAAKyE,mBAAmBT,EAAqBtC,EAAkB,M,uCAI/D1B,KAAK8D,cADQ,IAEL/C,EAASf,KAAK6C,MAAd9B,KACFgD,EAAYhD,EAlHH,GACA,GAkHTU,EAAaV,EAjHN,IACA,IAiHPiD,EF7HP,SAAqBjD,EAAMgD,EAAWtC,GACzC,IAAMuC,EAAsB,GACtBxB,EAAS,GAMf,IAJAuB,EAAUzB,SAAW,EACrByB,EAAUrB,OAASZ,EAAqBiC,EAAWtC,GACnDe,EAAOtB,KAAK6C,GAELvB,EAAOnB,OAAS,GAAG,CAEtBmB,EAAO0B,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAEzB,OAAS0B,EAAE1B,UACnC,IAAMf,EAAca,EAAO8B,QAG3B,GADAN,EAAoB9C,KAAKS,GACrBA,IAAgBF,EAAY,OAAOuC,EACvCzB,EAAgBZ,EAAaZ,EAAMU,EAAYe,GAEnD,OAAOwB,EE4GyBa,CAAY9D,EAAMgD,EAAWtC,GACnD+C,EAA2BhD,EAAoBC,GACrDzB,KAAKyE,mBAAmBT,EAAqBQ,EAA0B,M,qCAIvExE,KAAK8D,cADM,IAEH/C,EAASf,KAAK6C,MAAd9B,KACFgD,EAAYhD,EA5HH,GACA,GA4HTU,EAAaV,EA3HN,IACA,IA2HPiD,ECvIP,SAAajD,EAAMgD,EAAWtC,GACjC,IAAIqD,EAAQ,GACZA,EAAM5D,KAAK6C,GACXA,EAAU1B,WAAY,EAItB,IAFA,IAAM2B,EAAsB,GAErBc,EAAMzD,OAAS,GAAG,CACrB,IAAMM,EAAcmD,EAAMR,QAG1B,GADAN,EAAoB9C,KAAKS,GACrBA,IAAgBF,EAAY,OAAOuC,EAEvC,IANqB,EAOf5B,EADYjB,EAAaQ,EAAaZ,GACPO,QAAO,SAAAC,GAAQ,OAAKA,EAASc,aAP7C,cAQED,GARF,IAQrB,2BAA2C,CAAC,IAAjCb,EAAgC,QACvCA,EAASc,WAAY,EACrBd,EAASM,aAAeF,EACxBmD,EAAM5D,KAAKK,IAXM,+BAezB,OAAOyC,EDiHyBe,CAAIhE,EAAMgD,EAAWtC,GAC3C+C,EAA2BhD,EAAoBC,GACrDzB,KAAKyE,mBAAmBT,EAAqBQ,EAA0B,M,qCAIvExE,KAAK8D,cADM,IAEH/C,EAASf,KAAK6C,MAAd9B,KACFgD,EAAYhD,EAtIH,GACA,GAsITU,EAAaV,EArIN,IACA,IAqIPiD,EEjJP,SAAajD,EAAMgD,EAAWtC,GACjC,IAAMuD,EAAQ,GACRhB,EAAsB,GAI5B,IAFAgB,EAAM9D,KAAK6C,GAEJiB,EAAM3D,OAAS,GAAG,CACrB,IAAMM,EAAcqD,EAAMC,MAI1B,GAFAtD,EAAYU,WAAY,EACxB2B,EAAoB9C,KAAKS,GACrBA,IAAgBF,EAAY,OAAOuC,EAEvC,IAPqB,EAQf5B,EADYjB,EAAaQ,EAAaZ,GACPO,QAAO,SAAAC,GAAQ,OAAKA,EAASc,aAR7C,cASED,GATF,IASrB,2BAA2C,CAAC,IAAjCb,EAAgC,QACvCA,EAASM,aAAeF,EACxBqD,EAAM9D,KAAKK,IAXM,+BAezB,OAAOyC,EF4HyBkB,CAAInE,EAAMgD,EAAWtC,GAC3CC,EAAmBF,EAAoBC,GAC7CzB,KAAKyE,mBAAmBT,EAAqBtC,EAAkB,M,yCAGhDsC,EAAqBQ,EAA0BW,GAC9D,IADsE,IAAD,kBAC5DC,GACL,GAAIA,IAAMpB,EAAoB3C,OAAS,EAInC,OAHAgE,YAAW,WACP,EAAKC,YAAYd,EAA0BW,KAC5C,GAAKC,GACF,CAAN,UAEJC,YAAW,WACP,IAAMpE,EAAO+C,EAAoBoB,GACjC3B,SAAS8B,eAAT,eAAgCtE,EAAKd,IAArC,YAA4Cc,EAAKf,MAAOU,UACpD,sBACL,GAAKwE,IAXHA,EAAI,EAAGA,GAAKpB,EAAoB3C,OAAS,EAAG+D,IAAK,CAAC,IAAD,IAAjDA,GAAiD,qC,kCAelD1D,EAAkByD,GAC1B,IADkC,IAAD,kBACxBC,GACLC,YAAW,WACP,IAAMpE,EAAOS,EAAiB0D,GAC9B3B,SAAS8B,eAAT,eAAgCtE,EAAKd,IAArC,YAA4Cc,EAAKf,MAAOU,UACpD,mBACLuE,EAAQC,IALNA,EAAI,EAAGA,EAAI1D,EAAiBL,OAAS,EAAG+D,IAAM,EAA9CA,GAOTC,YAAW,WACP,EAAKG,uBACNL,EAAQzD,EAAiBL,U,kCAGnB,IAAD,OACRrB,KAAKgD,aAELqC,YAAW,WACP,EAAKI,mBACN,O,2CAMH,IAHkB,IAEZpC,EADWrD,KAAK6C,MAAd9B,KACawC,QACZpD,EAAM,EAAGA,EAAMkD,EAAQhC,OAAQlB,IACpC,IAAI,IAAID,EAAM,EAAGA,EAAMmD,EAAQ,GAAGhC,OAAQnB,IAAO,CAC7C,IAAMe,EAAOoC,EAAQlD,GAAKD,GACpBsD,EAAO,2BACNvC,GADM,IAETqB,SAAUc,IACVV,OAAQU,IACRvB,aAAc,KACdQ,WAAW,IAEfgB,EAAQlD,GAAKD,GAAOsD,EAG5BxD,KAAKmD,SAAS,CAAEpC,KAAMsC,IACtBrD,KAAKyF,mB,uCAGS,IAAD,SACPC,EAAW,GADJ,cAEK1F,KAAK6C,MAAM9B,MAFhB,IAEb,2BAAmC,CAAC,IAAD,EAAxBZ,EAAwB,sBACZA,GADY,IAC/B,2BAAwB,CAAC,IAAdc,EAAa,QACpByE,EAASxE,KAAKD,IAFa,gCAFtB,8BAOb,IAPa,eAOJmE,GACLC,YAAW,WACP,IAAMpE,EAAOyE,EAASN,GAClBnE,EAAKb,QACLqD,SAAS8B,eAAT,eAAgCtE,EAAKd,IAArC,YAA4Cc,EAAKf,MAAOU,UACpD,kBACGK,EAAKZ,SACZoD,SAAS8B,eAAT,eAAgCtE,EAAKd,IAArC,YAA4Cc,EAAKf,MAAOU,UACpD,mBACGK,EAAKX,OACZmD,SAAS8B,eAAT,eAAgCtE,EAAKd,IAArC,YAA4Cc,EAAKf,MAAOU,UACpD,iBAEJ6C,SAAS8B,eAAT,eAAgCtE,EAAKd,IAArC,YAA4Cc,EAAKf,MAAOU,UACpD,SAET,EAAIwE,IAhBFA,EAAI,EAAGA,EAAIM,EAASrE,OAAQ+D,IAAM,EAAlCA,GAkBTC,YAAW,WACP,EAAKM,wBACND,EAASrE,U,+BAGN,IAAD,SAC6BrB,KAAK6C,MAA/B9B,EADH,EACGA,KAAOgC,EADV,EACUA,eAEf,OACI,6BACI,wDACA,4BAAQnC,UAAU,YAAYgF,QAAS,kBAAM,EAAKC,iBAAlD,sBAGA,4BAAQjF,UAAU,YAAYgF,QAAS,kBAAM,EAAKE,iBAAlD,wBAGA,4BAAQlF,UAAU,YAAYgF,QAAS,kBAAM,EAAKG,sBAAlD,wBAGA,4BAAQnF,UAAU,YAAYgF,QAAS,kBAAM,EAAKI,oBAAlD,iBAGA,4BAAQrF,GAAG,WAAWC,UAAU,YAAYgF,QAAS,kBAAM,EAAKK,mBAAhE,iBAGA,yBAAKrF,UAAU,QACVG,EAAKmF,KAAI,SAAC/F,EAAKgG,GACZ,OACI,yBAAKC,IAAKD,GACLhG,EAAI+F,KAAI,SAACjF,EAAMoF,GAAY,IACjBlG,EAAuCc,EAAvCd,IAAKD,EAAkCe,EAAlCf,IAAKE,EAA6Ba,EAA7Bb,QAASC,EAAoBY,EAApBZ,SAAUC,EAAUW,EAAVX,OACpC,OACI,kBAAC,EAAD,CACI8F,IAAKC,EACLnG,IAAKA,EACLC,IAAKA,EACLC,QAASA,EACTC,SAAUA,EACVC,OAAQA,EACRyC,eAAgBA,EAChBxC,YAAa,SAACJ,EAAKD,GAAN,OAAc,EAAKoG,gBAAgBnG,EAAKD,IACrDM,aAAc,SAACL,EAAKD,GAAN,OAAc,EAAKqG,iBAAiBpG,EAAKD,IACvDO,UAAW,kBAAM,EAAK+F,2BASlD,4BAAQ5F,UAAU,WAAWgF,QAAS,kBAAM,EAAKa,cAAjD,cAGA,4BAAQ9F,GAAG,cAAcC,UAAU,WAAWgF,QAAS,kBAAM,EAAKc,uBAAlE,yBAIA,uBAAGC,MAAO,CAACC,UAAW,WAAtB,iIAKA,yBAAKhG,UAAU,uBACX,kBAAC,EAAD,Y,GA3RgBC,aGJrBgG,MARf,WACE,OACE,yBAAKjG,UAAU,OACb,kBAAC,EAAD,QCKckG,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEF5D,SAAS8B,eAAe,SDyHpB,kBAAmB+B,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLnD,QAAQmD,MAAMA,EAAMC,c","file":"static/js/main.61fe9129.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport '../styles/GridNode.css'\n\nclass GridNode extends Component {\n    render() { \n        const { col, \n                row, \n                isStart, \n                isFinish, \n                isWall,\n                onMouseDown,\n                onMouseEnter,\n                onMouseUp \n            } = this.props;\n\n        const extraClassName = isFinish ? 'node-finish'\n                                : isStart ? 'node-start'\n                                : isWall ? 'node-wall'\n                                : '';\n        \n        return ( \n            <div\n                id={`node-${row}-${col}`}\n                className={`node ${extraClassName}`}\n                onMouseDown={() => onMouseDown(row, col)}\n                onMouseEnter={() => onMouseEnter(row, col)}\n                onMouseUp={() => onMouseUp()}>\n            </div>\n        );\n    }\n}\n \nexport default GridNode;","// gets all nodes within grid and returns as array\nexport function getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\n// gets all neighbors of passed node (excluiding nodes that are walls) and returns as array\nexport function getNeighbors(node, grid) {\n    const neighbors = [];\n    const { col, row } = node;\n    if (col > 0) neighbors.push(grid[row][col - 1]); // left one\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]); // down one\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]); // right one\n    if (row > 0) neighbors.push(grid[row - 1][col]); // up one\n    return neighbors.filter(neighbor => !neighbor.isWall); // filter out walls\n    // return neighbors.filter(neighbor => !neighbor.isVisited); // make sure the nodes haven't already been visited\n}\n\n// backtracks from the finishNode to construct the path that was found\nexport function getNodesInPathOrder(finishNode) {\n    const nodesInPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInPathOrder.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInPathOrder;\n}\n\n// returns manhattan distance between two nodes\nexport function getManhattanDistance(nodeA, nodeB) {\n    const dx = Math.abs(nodeA.col - nodeB.col);\n    const dy = Math.abs(nodeA.row - nodeB.row);\n    return (dx + dy);\n}","import { getAllNodes, getNeighbors } from '../algorithms/helper-functions';\n\nexport function dijkstra(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const unvisitedNodes = getAllNodes(grid);\n\n    while (unvisitedNodes.length > 0) { \n        // sort nodes by distance, closest node to front of array\n        unvisitedNodes.sort((a, b) => a.distance - b.distance);\n        const closestNode = unvisitedNodes.shift();\n\n        // if trapped by walls exit/return\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n        closestNode.isVisited = true;\n        visitedNodesInOrder.push(closestNode);\n        if (closestNode === finishNode) return visitedNodesInOrder;\n        updateUnvisitedNeighbors(closestNode, grid);\n    }\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n    const neighbors = getNeighbors(node, grid);\n    const unvisitedNeighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = node.distance + 1;\n        neighbor.previousNode = node;\n    }\n}","import { getAllNodes, getNeighbors, getManhattanDistance } from '../algorithms/helper-functions';\n\nexport function greedySearch(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    const unvisitedNodes = getAllNodes(grid);\n\n    startNode.distance = getManhattanDistance(startNode, finishNode);\n\n    while (unvisitedNodes.length > 0) {\n        // sort nodes by distance, closest to front of array\n        unvisitedNodes.sort((a, b) => a.distance - b.distance);\n        const closestNode = unvisitedNodes.shift();\n\n        // if trapped by walls exit/return\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n        closestNode.isVisited = true;\n        visitedNodesInOrder.push(closestNode);\n        if (closestNode === finishNode) return visitedNodesInOrder;\n        updateUnvisitedNeighbors(closestNode, grid, finishNode);\n    }\n}\n\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {    \n    const neighbors = getNeighbors(node, grid);\n    const unvisitedNeighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = getManhattanDistance(neighbor, finishNode);\n        neighbor.previousNode = node;\n    }\n}","import { getNeighbors, getManhattanDistance } from '../algorithms/helper-functions';\n\nexport function aStarSearch(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    const pQueue = [];\n    \n    startNode.distance = 0;\n    startNode.fScore = getManhattanDistance(startNode, finishNode);\n    pQueue.push(startNode);\n\n    while (pQueue.length > 0) {\n        // sort nodes by distance, closest to front of queue\n        pQueue.sort((a, b) => a.fScore - b.fScore);\n        const currentNode = pQueue.shift();\n\n        visitedNodesInOrder.push(currentNode);\n        if (currentNode === finishNode) return visitedNodesInOrder;\n        updateNeighbors(currentNode, grid, finishNode, pQueue);\n    }\n    return visitedNodesInOrder; // trapped by walls, no path available\n}\n\nfunction updateNeighbors(node, grid, finishNode, pQueue) {\n    const neighbors = getNeighbors(node, grid);\n    for (const neighbor of neighbors) { \n        const temp = node.distance + 1;\n        if (temp < neighbor.distance) { \n            neighbor.previousNode = node;\n            neighbor.distance = temp;\n            neighbor.fScore = temp + getManhattanDistance(neighbor, finishNode);\n            if (!pQueue.includes(neighbor)) {\n                pQueue.push(neighbor);\n            }\n        }\n    }\n}","import React, { Component } from 'react';\nimport '../styles/instructions.css';\n\nclass Instuctions extends Component {\n    state = {  }\n    render() { \n        return ( \n            <div>\n                <h2> What is Pathfinding? </h2>\n                <p>\n                    This application visualizes various pathfinding algorithms. \n                    A pathfinding algorithm is essentially trying to find\n                    the shortest path between two points. While some algorithms\n                    are guaranteed to find the shortest possible path, others are not. \n                    Below are descriptions of each algorithm implemented in this\n                    application.\n                </p>\n\n                <h2> The Algorithms </h2>\n\n                <div className=\"alg-description-1\">\n                    <h4> Depth-First Search (DFS) </h4>\n                    <p className=\"alg-des-italic\"> unweighted </p>\n                    <p className=\"alg-des\">\n                        Explores as far as possible until hitting the end of the grid,\n                        a wall, or an already visited node before changing direction.\n                    </p>\n                    <p>\n                        does not guarantee shortest path\n                    </p>\n                </div>\n\n                <div className=\"alg-description-1\">\n                    <h4> Breadth-First Search (BFS) </h4>\n                    <p className=\"alg-des-italic\"> unweighted (can be weighted) </p>\n                    <p className=\"alg-des\">\n                        Explores all neighbors of the start node then continues\n                        to explore the neighbors of those nodes and so on until\n                        it finds the target node.\n                    </p>\n                    <p>\n                        guarantees shortest path\n                    </p>\n                </div>\n\n                <div className=\"alg-description-1\">\n                    <h4> Dijkstra's Algorithm </h4>\n                    <p className=\"alg-des-italic\"> weighted </p>\n                    <p className=\"alg-des\">\n                        Explores all neighbors of the start node and moves to the neighbor\n                        with the lowest cost. In this case, since each neighbor node has\n                        an equal cost of 1, it will move to the node explored first.\n                        For this implementation that order is up, right, down, left.\n                    </p>\n                    <p>\n                        guarantees shortest path\n                    </p>\n                </div>\n\n                <div className=\"alg-description-1\">\n                    <h4> Greedy Search </h4>\n                    <p className=\"alg-des-italic\"> weighted </p>\n                    <p className=\"alg-des\">\n                        Uses a heuristic function to estimate the cost of the cheapest path\n                        from start node to destination node. Essentially, it will explore\n                        neighbors and continuously move to the node that is closest to the\n                        destination node. This does not always lead to the optimal path.\n                    </p>\n                    <p>\n                        does not guarantee shortest path\n                    </p>\n                </div>\n\n                <div className=\"alg-description-1\">\n                    <h4> A* (A-Star) Search </h4>\n                    <p className=\"alg-des-italic\"> weighted </p>\n                    <p className=\"alg-des\">\n                        When deciding which direction to go, the A-Star algorithm considers both \n                        the cost from the current node any neighbor node (like Dijkstras) \n                        along with the distance from those neighbor nodes to the\n                        destination node (like Greedy) to predict which neighbor node would\n                        be the best move. This results in an algorithm that is much faster than \n                        Dijkstras but still guarantees the shortest path. This is one of the \n                        best pathfinding algorithms.\n                    </p>\n                    <p>\n                        guarantees shortest path\n                    </p>\n                </div>\n\n                <h3> Calculating Distance </h3>\n                <p>\n                    For weighted algorithms this application uses manhattan distance to\n                    calculate cost. Each movement from one node to a neighboring node \n                    has a cost or weight of 1. \n                </p>\n            </div>\n        );\n    }\n}\n \nexport default Instuctions;","import React, { Component } from 'react';\nimport '../styles/PathFindingVisualizer.css';\nimport GridNode from './GridNode'\nimport { dijkstra } from '../algorithms/Dijkstras';\nimport { greedySearch } from '../algorithms/GreedySearch';\nimport { aStarSearch } from '../algorithms/AStarSearch';\nimport { bfs } from '../algorithms/BreadthFirstSearch';\nimport { dfs } from '../algorithms/DepthFirstSearch';\nimport { getNodesInPathOrder } from '../algorithms/helper-functions';\nimport Instructions from './instructions.jsx'\n\nconst START_NODE_ROW = 4;\nconst START_NODE_COL = 4;\nconst END_NODE_ROW = 15;\nconst END_NODE_COL = 35;\n\nclass PathFindingVisualizer extends Component {\n    state = {\n        grid: [],\n        mouseIsPressed: false,\n    };\n    \n    componentDidMount() {\n        this.createGrid();\n    }\n\n    createGrid() {\n        const grid = [];\n        for (let row = 0; row < 20; row++) {\n            const currentRow = [];\n            for (let col = 0; col < 40; col++) {\n                currentRow.push(this.createNode(col, row));\n            }\n            grid.push(currentRow);\n        }\n        this.setState({\n            grid: grid,\n        });\n    };\n\n    createNode(col, row) {\n        return {\n            col: col,\n            row: row,\n            distance: Infinity,\n            fScore: Infinity,\n            previousNode: null,\n            isStart: row === START_NODE_ROW && col === START_NODE_COL,\n            isFinish: row === END_NODE_ROW && col === END_NODE_COL,\n            isWall: false,\n            isVisited: false,\n        };\n    };\n\n    handleMouseDown(row, col) {\n        const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\n        this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n\n    handleMouseEnter(row, col) {\n        if (!this.state.mouseIsPressed) return;\n        const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\n        this.setState({ grid: newGrid });\n    }\n\n    handleMouseUp() {\n        this.setState({ mouseIsPressed: false });\n    }\n\n    getNewGridWithWallToggled(grid, row, col) {\n        const newGrid = grid.slice();\n        const node = newGrid[row][col];\n        const newNode = {\n            ...node,\n            isWall: !node.isWall,\n        };\n        newGrid[row][col] = newNode;\n        return newGrid;\n    };\n\n    lockButtons() { \n        const buttons = document.querySelectorAll('button');\n        buttons.forEach((button) => {\n            button.disabled = true;\n        });\n    }\n\n    unlockSearchButtons() { \n        const buttons = document.querySelectorAll('.searchBtn');\n        buttons.forEach((button) => {\n            button.disabled = false;\n        });\n    }\n\n    unlockResetButtons() {\n        const buttons = document.querySelectorAll('.resetBtn');\n        buttons.forEach((button) => {\n            button.disabled = false;\n        });\n    }\n\n    visualizeDijkstra() {\n        this.lockButtons();\n        const { grid } = this.state;\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\n        const finishNode = grid[END_NODE_ROW][END_NODE_COL];\n        const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n        const nodesInShortestPathOrder = getNodesInPathOrder(finishNode);\n        this.animateExploration(visitedNodesInOrder, nodesInShortestPathOrder, 30);\n        console.log(grid);\n    }\n\n    visualizeGreedy() {\n        this.lockButtons();\n        const { grid } = this.state;\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\n        const finishNode = grid[END_NODE_ROW][END_NODE_COL];\n        const visitedNodesInOrder = greedySearch(grid, startNode, finishNode);\n        const nodesInPathOrder = getNodesInPathOrder(finishNode);\n        this.animateExploration(visitedNodesInOrder, nodesInPathOrder, 30);\n    }\n\n    visualizeAStar() {\n        this.lockButtons();\n        const { grid } = this.state;\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\n        const finishNode = grid[END_NODE_ROW][END_NODE_COL];\n        const visitedNodesInOrder = aStarSearch(grid, startNode, finishNode);\n        const nodesInShortestPathOrder = getNodesInPathOrder(finishNode);\n        this.animateExploration(visitedNodesInOrder, nodesInShortestPathOrder, 30);\n    }\n\n    visualizeBFS() {\n        this.lockButtons();\n        const { grid } = this.state;\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\n        const finishNode = grid[END_NODE_ROW][END_NODE_COL];\n        const visitedNodesInOrder = bfs(grid, startNode, finishNode);\n        const nodesInShortestPathOrder = getNodesInPathOrder(finishNode);\n        this.animateExploration(visitedNodesInOrder, nodesInShortestPathOrder, 30);\n    }\n\n    visualizeDFS() {\n        this.lockButtons();\n        const { grid } = this.state;\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\n        const finishNode = grid[END_NODE_ROW][END_NODE_COL];\n        const visitedNodesInOrder = dfs(grid, startNode, finishNode);\n        const nodesInPathOrder = getNodesInPathOrder(finishNode);\n        this.animateExploration(visitedNodesInOrder, nodesInPathOrder, 30);\n    }\n\n    animateExploration(visitedNodesInOrder, nodesInShortestPathOrder, speed) {\n        for (let i = 1; i <= visitedNodesInOrder.length - 1; i++) {\n            if (i === visitedNodesInOrder.length - 1) {\n                setTimeout(() => {\n                    this.animatePath(nodesInShortestPathOrder, speed);\n                }, 10 * i);\n                return;\n            }\n            setTimeout(() => {\n                const node = visitedNodesInOrder[i];\n                document.getElementById(`node-${node.row}-${node.col}`).className =\n                    'node node-visited';\n            }, 10 * i);\n        }\n    }\n\n    animatePath(nodesInPathOrder, speed) {\n        for (let i = 1; i < nodesInPathOrder.length - 1; i++) {\n            setTimeout(() => {\n                const node = nodesInPathOrder[i];\n                document.getElementById(`node-${node.row}-${node.col}`).className =\n                    'node node-path';\n            }, speed * i);\n        }\n        setTimeout(() => {\n            this.unlockResetButtons();\n        }, speed * nodesInPathOrder.length);\n    }\n\n    resetGrid() { \n        this.createGrid();\n        // need a delay for the new grid to be set in state\n        setTimeout(() => {\n            this.resetNodeColor();\n        }, 250);\n    }\n\n    resetGridKeepWalls() { \n        const { grid } = this.state;\n        const newGrid = grid.slice();\n        for (let row = 0; row < newGrid.length; row++) {\n            for(let col = 0; col < newGrid[0].length; col++) {\n                const node = newGrid[row][col];\n                const newNode = {\n                    ...node,\n                    distance: Infinity,\n                    fScore: Infinity,\n                    previousNode: null,\n                    isVisited: false\n                }\n                newGrid[row][col] = newNode;\n            }\n        }\n        this.setState({ grid: newGrid });\n        this.resetNodeColor();\n    }\n\n    resetNodeColor() { \n        const allNodes = [];\n        for (const row of this.state.grid) {\n            for (const node of row) {\n                allNodes.push(node);\n            }\n        }\n        for (let i = 0; i < allNodes.length; i++) {\n            setTimeout(() => {\n                const node = allNodes[i];\n                if (node.isStart) {\n                    document.getElementById(`node-${node.row}-${node.col}`).className =\n                        'node node-start';\n                } else if (node.isFinish) {\n                    document.getElementById(`node-${node.row}-${node.col}`).className =\n                        'node node-finish';\n                } else if (node.isWall) { \n                    document.getElementById(`node-${node.row}-${node.col}`).className =\n                        'node node-wall';\n                } else {\n                    document.getElementById(`node-${node.row}-${node.col}`).className =\n                        'node';\n                }\n            }, 1 * i);\n        }\n        setTimeout(() => {\n            this.unlockSearchButtons();\n        }, allNodes.length);\n    }\n\n    render() { \n        const { grid,  mouseIsPressed } = this.state;\n\n        return ( \n            <div>\n                <h1> Pathfinding Visualizer </h1> \n                <button className=\"searchBtn\" onClick={() => this.visualizeDFS()}>\n                    Depth-First Search\n                </button>\n                <button className=\"searchBtn\" onClick={() => this.visualizeBFS()}>\n                    Breadth-First Search\n                </button>\n                <button className=\"searchBtn\" onClick={() => this.visualizeDijkstra()}>\n                    Dijkstra's Algorithm\n                </button>\n                <button className=\"searchBtn\" onClick={() => this.visualizeGreedy()}>\n                    Greedy Search\n                </button>\n                <button id=\"aStarBtn\" className=\"searchBtn\" onClick={() => this.visualizeAStar()}>\n                    A-Star Search\n                </button>\n                <div className=\"grid\">\n                    {grid.map((row, rIndex) => {\n                        return (\n                            <div key={rIndex}>\n                                {row.map((node, nIndex) => { \n                                    const {row, col, isStart, isFinish, isWall} = node;\n                                    return (\n                                        <GridNode\n                                            key={nIndex}\n                                            col={col}\n                                            row={row}\n                                            isStart={isStart}\n                                            isFinish={isFinish}\n                                            isWall={isWall}\n                                            mouseIsPressed={mouseIsPressed}\n                                            onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                                            onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                                            onMouseUp={() => this.handleMouseUp()}>\n                                        </GridNode>\n                                    );\n                                })}\n                            </div>\n                        );\n                    })}\n                </div>\n\n                <button className=\"resetBtn\" onClick={() => this.resetGrid()}>\n                    Reset Grid\n                </button>\n                <button id=\"resetBtnTwo\" className=\"resetBtn\" onClick={() => this.resetGridKeepWalls()}>\n                    Reset Grid Keep Walls\n                </button>\n\n                <p style={{fontStyle: \"italic\"}}>\n                    Add walls by clicking and holding down your left mouse button while\n                    moving it around the grid. To clear a wall left-click it.\n                </p>\n                \n                <div className=\"instruction-wrapper\">\n                    <Instructions />\n                </div>\n            </div>\n        );\n    }\n}\n \nexport default PathFindingVisualizer;","import { getNeighbors } from '../algorithms/helper-functions';\n\nexport function bfs(grid, startNode, finishNode) {\n    let queue = [];\n    queue.push(startNode);\n    startNode.isVisited = true;\n\n    const visitedNodesInOrder = [];\n\n    while (queue.length > 0) {\n        const currentNode = queue.shift();\n        \n        visitedNodesInOrder.push(currentNode);\n        if (currentNode === finishNode) return visitedNodesInOrder;\n\n        const neighbors = getNeighbors(currentNode, grid);\n        const unvisitedNeighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n        for (const neighbor of unvisitedNeighbors) {\n            neighbor.isVisited = true;\n            neighbor.previousNode = currentNode;\n            queue.push(neighbor);\n        }\n    }\n    // finish node was not found and therefore we must be trapped by walls\n    return visitedNodesInOrder;\n}","import { getNeighbors } from '../algorithms/helper-functions';\n\nexport function dfs(grid, startNode, finishNode) {\n    const stack = [];\n    const visitedNodesInOrder = [];\n\n    stack.push(startNode);\n\n    while (stack.length > 0) {\n        const currentNode = stack.pop();\n\n        currentNode.isVisited = true;\n        visitedNodesInOrder.push(currentNode);\n        if (currentNode === finishNode) return visitedNodesInOrder;\n\n        const neighbors = getNeighbors(currentNode, grid);\n        const unvisitedNeighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n        for (const neighbor of unvisitedNeighbors) { \n            neighbor.previousNode = currentNode;\n            stack.push(neighbor);\n        }\n    }\n    // finish node was not found and therefore we must be trapped by walls\n    return visitedNodesInOrder;\n}","import React from 'react';\nimport './App.css';\nimport PathFindingVisualizer from './components/PathFindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFindingVisualizer /> \n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}